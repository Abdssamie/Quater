using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Quater.Backend.Core.DTOs;
using Quater.Backend.Core.Tests.Helpers;
using Quater.Backend.Data;
using Quater.Backend.Services;
using Quater.Shared.Enums;
using Quater.Shared.Models;
using Xunit;

namespace Quater.Backend.Core.Tests.Services;

/// <summary>
/// Integration tests for AuditLogService using PostgreSQL test container
/// </summary>
[Collection("PostgreSQL")]
public class AuditLogServiceIntegrationTests : IAsyncLifetime
{
    private readonly PostgresTestContainerFixture _fixture;
    private QuaterDbContext _context = null!;
    private AuditLogService _service = null!;
    private readonly DateTime _baseTime = new(2025, 1, 1, 12, 0, 0, DateTimeKind.Utc);

    public AuditLogServiceIntegrationTests(PostgresTestContainerFixture fixture)
    {
        _fixture = fixture;
    }

    public async Task InitializeAsync()
    {
        // Reset database before each test
        await _fixture.Container.ResetDatabaseAsync();

        _context = _fixture.Container.CreateDbContext();
        _service = new AuditLogService(_context);

        // Seed some audit logs for testing
        await SeedAuditLogsAsync();
    }

    public async Task DisposeAsync()
    {
        await _context.DisposeAsync();
    }

    private async Task SeedAuditLogsAsync()
    {
        // Seed lab first
        var lab = new Lab { Id = Guid.NewGuid(), Name = "Test Lab", IsActive = true };
        _context.Labs.Add(lab);
        await _context.SaveChangesAsync();

        // Seed users
        var userId1 = Guid.Parse("550e8400-e29b-41d4-a716-446655440010");
        var userId2 = Guid.Parse("550e8400-e29b-41d4-a716-446655440011");

        var users = new List<User>
        {
            new() { Id = userId1, UserName = "user1", Email = "user1@example.com", SecurityStamp = "stamp1", UserLabs = [ new UserLab { LabId = lab.Id, Role = UserRole.Technician } ] },
            new() { Id = userId2, UserName = "user2", Email = "user2@example.com", SecurityStamp = "stamp2", UserLabs = [ new UserLab { LabId = lab.Id, Role = UserRole.Technician } ] }
        };
        _context.Users.AddRange(users);
        await _context.SaveChangesAsync();

        // Clear audit logs generated by interceptors during seeding
        _context.AuditLogs.RemoveRange(_context.AuditLogs);
        await _context.SaveChangesAsync();

        var logs = new List<AuditLog>
        {
            // Sample logs
            new()
            {
                Id = Guid.NewGuid(),
                Action = AuditAction.Create,
                EntityType = EntityType.Sample,
                EntityId = Guid.Parse("11111111-1111-1111-1111-111111111111"),
                UserId = userId1,
                Timestamp = _baseTime, // Jan 1
                IpAddress = "127.0.0.1"
            },
            new()
            {
                Id = Guid.NewGuid(),
                Action = AuditAction.Update,
                EntityType = EntityType.Sample,
                EntityId = Guid.Parse("11111111-1111-1111-1111-111111111111"),
                UserId = userId1,
                Timestamp = _baseTime.AddDays(1), // Jan 2
                IpAddress = "127.0.0.1"
            },
            // Lab logs
            new()
            {
                Id = Guid.NewGuid(),
                Action = AuditAction.Create,
                EntityType = EntityType.Lab,
                EntityId = Guid.Parse("22222222-2222-2222-2222-222222222222"),
                UserId = userId2,
                Timestamp = _baseTime.AddDays(2), // Jan 3
                IpAddress = "192.168.1.1"
            },
            // Archived log (should be filtered out by default)
            new()
            {
                Id = Guid.NewGuid(),
                Action = AuditAction.Delete,
         EntityType = EntityType.Sample,
                EntityId = Guid.Parse("33333333-3333-3333-3333-333333333333"),
                UserId = userId1,
                Timestamp = _baseTime.AddMonths(-6), // Old log
                IpAddress = "127.0.0.1",
                IsArchived = true
            }
        };

        _context.AuditLogs.AddRange(logs);
        await _context.SaveChangesAsync();
    }

    [Fact]
    public async Task GetAllAsync_ReturnsNonArchivedLogs_OrderedByTimestampDesc()
    {
        // Act
        var result = await _service.GetAllAsync();

        // Assert
        result.Should().NotBeNull();
        result.Items.Should().HaveCount(3); // 3 active logs, 1 archived
        result.TotalCount.Should().Be(3);

        // Verify ordering (newest first)
        var items = result.Items.ToList();
        items[0].Timestamp.Should().Be(_baseTime.AddDays(2)); // Jan 3
        items[1].Timestamp.Should().Be(_baseTime.AddDays(1)); // Jan 2
        items[2].Timestamp.Should().Be(_baseTime);            // Jan 1
    }

    [Fact]
    public async Task GetByEntityAsync_FiltersCorrectly()
    {
        // Act
        var result = await _service.GetByEntityAsync(Guid.Parse("11111111-1111-1111-1111-111111111111"));

        // Assert
        result.Items.Should().HaveCount(2);
        result.Items.All(x => x.EntityType == EntityType.Sample).Should().BeTrue();
    }

    [Fact]
    public async Task GetByUserAsync_FiltersCorrectly()
    {
        // Act
        var userId2 = Guid.Parse("550e8400-e29b-41d4-a716-446655440011");
        var result = await _service.GetByUserAsync(userId2);

        // Assert
        result.Items.Should().HaveCount(1);
        result.Items.First().UserId.Should().Be(userId2);
        result.Items.First().EntityType.Should().Be(EntityType.Lab);
    }

    [Fact]
    public async Task GetByFilterAsync_WithDateRange_FiltersCorrectly()
    {
        // Arrange
        var filter = new AuditLogFilterDto
        {
            StartDate = _baseTime.AddDays(0.5), // Jan 1, 12:00 PM
            EndDate = _baseTime.AddDays(1.5)    // Jan 2, 12:00 PM
        };

        // Act
        var result = await _service.GetByFilterAsync(filter);

        // Assert
        // Should catch the Jan 2 log (Update Sample)
        // Should NOT catch Jan 1 (Create Sample) or Jan 3 (Create Lab)

        // Let's try a strict range that only includes the middle log (Jan 2)
        var strictFilter = new AuditLogFilterDto
        {
            StartDate = _baseTime.AddDays(0.9), // Jan 1 Late
            EndDate = _baseTime.AddDays(1.1)    // Jan 2 Early
        };

        var strictResult = await _service.GetByFilterAsync(strictFilter);

        strictResult.Items.Should().Contain(x => x.Action == AuditAction.Update);
        strictResult.Items.Should().NotContain(x => x.Action == AuditAction.Create && x.EntityType == EntityType.Lab); // Jan 3
    }

    [Fact]
    public async Task GetByFilterAsync_IncludeArchived_ReturnsAllLogs()
    {
        // Arrange
        var filter = new AuditLogFilterDto
        {
            IncludeArchived = true
        };

        // Act
        var result = await _service.GetByFilterAsync(filter);

        // Assert
        result.TotalCount.Should().Be(4); // 3 active + 1 archived
        result.Items.Should().Contain(x => x.IsArchived);
    }

    [Fact]
    public async Task GetByFilterAsync_MultipleFilters_WorksAsAndCondition()
    {
        // Arrange
        var filter = new AuditLogFilterDto
        {
            EntityType = EntityType.Sample,
            Action = AuditAction.Create
        };

        // Act
        var result = await _service.GetByFilterAsync(filter);

        // Assert
        result.Items.Should().HaveCount(1);
        var log = result.Items.First();
        log.EntityType.Should().Be(EntityType.Sample);
        log.Action.Should().Be(AuditAction.Create);
    }
}
