/*
 * Quater Water Quality Management API
 *
 * REST API for managing water quality testing data, compliance calculations, and laboratory operations
 *
 * The version of the OpenAPI document: v1
 * Contact: support@quater.app
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Quater.Desktop.Api.Client;

namespace Quater.Desktop.Api.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthorizationApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters
        /// </summary>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void ApiAuthAuthorizeGet(string? apiVersion = default, int operationIndex = 0);

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ApiAuthAuthorizeGetWithHttpInfo(string? apiVersion = default, int operationIndex = 0);
        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters
        /// </summary>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void ApiAuthAuthorizePost(string? apiVersion = default, int operationIndex = 0);

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ApiAuthAuthorizePostWithHttpInfo(string? apiVersion = default, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthorizationApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ApiAuthAuthorizeGetAsync(string? apiVersion = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ApiAuthAuthorizeGetWithHttpInfoAsync(string? apiVersion = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ApiAuthAuthorizePostAsync(string? apiVersion = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ApiAuthAuthorizePostWithHttpInfoAsync(string? apiVersion = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthorizationApi : IAuthorizationApiSync, IAuthorizationApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class AuthorizationApi : IAuthorizationApi
    {
        private Quater.Desktop.Api.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthorizationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AuthorizationApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthorizationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AuthorizationApi(string basePath)
        {
            this.Configuration = Quater.Desktop.Api.Client.Configuration.MergeConfigurations(
                Quater.Desktop.Api.Client.GlobalConfiguration.Instance,
                new Quater.Desktop.Api.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Quater.Desktop.Api.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Quater.Desktop.Api.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Quater.Desktop.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthorizationApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public AuthorizationApi(Quater.Desktop.Api.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Quater.Desktop.Api.Client.Configuration.MergeConfigurations(
                Quater.Desktop.Api.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Quater.Desktop.Api.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Quater.Desktop.Api.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Quater.Desktop.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthorizationApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public AuthorizationApi(Quater.Desktop.Api.Client.ISynchronousClient client, Quater.Desktop.Api.Client.IAsynchronousClient asyncClient, Quater.Desktop.Api.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Quater.Desktop.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Quater.Desktop.Api.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Quater.Desktop.Api.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Quater.Desktop.Api.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Quater.Desktop.Api.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters 
        /// </summary>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void ApiAuthAuthorizeGet(string? apiVersion = default, int operationIndex = 0)
        {
            ApiAuthAuthorizeGetWithHttpInfo(apiVersion);
        }

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters 
        /// </summary>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Quater.Desktop.Api.Client.ApiResponse<Object> ApiAuthAuthorizeGetWithHttpInfo(string? apiVersion = default, int operationIndex = 0)
        {
            Quater.Desktop.Api.Client.RequestOptions localVarRequestOptions = new Quater.Desktop.Api.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Quater.Desktop.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Quater.Desktop.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (apiVersion != null)
            {
                localVarRequestOptions.QueryParameters.Add(Quater.Desktop.Api.Client.ClientUtils.ParameterToMultiMap("", "api-version", apiVersion));
            }

            localVarRequestOptions.Operation = "AuthorizationApi.ApiAuthAuthorizeGet";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Get<Object>("/api/auth/authorize", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ApiAuthAuthorizeGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters 
        /// </summary>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ApiAuthAuthorizeGetAsync(string? apiVersion = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            await ApiAuthAuthorizeGetWithHttpInfoAsync(apiVersion, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters 
        /// </summary>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Quater.Desktop.Api.Client.ApiResponse<Object>> ApiAuthAuthorizeGetWithHttpInfoAsync(string? apiVersion = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            Quater.Desktop.Api.Client.RequestOptions localVarRequestOptions = new Quater.Desktop.Api.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Quater.Desktop.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Quater.Desktop.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (apiVersion != null)
            {
                localVarRequestOptions.QueryParameters.Add(Quater.Desktop.Api.Client.ClientUtils.ParameterToMultiMap("", "api-version", apiVersion));
            }

            localVarRequestOptions.Operation = "AuthorizationApi.ApiAuthAuthorizeGet";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Object>("/api/auth/authorize", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ApiAuthAuthorizeGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters 
        /// </summary>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void ApiAuthAuthorizePost(string? apiVersion = default, int operationIndex = 0)
        {
            ApiAuthAuthorizePostWithHttpInfo(apiVersion);
        }

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters 
        /// </summary>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Quater.Desktop.Api.Client.ApiResponse<Object> ApiAuthAuthorizePostWithHttpInfo(string? apiVersion = default, int operationIndex = 0)
        {
            Quater.Desktop.Api.Client.RequestOptions localVarRequestOptions = new Quater.Desktop.Api.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Quater.Desktop.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Quater.Desktop.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (apiVersion != null)
            {
                localVarRequestOptions.QueryParameters.Add(Quater.Desktop.Api.Client.ClientUtils.ParameterToMultiMap("", "api-version", apiVersion));
            }

            localVarRequestOptions.Operation = "AuthorizationApi.ApiAuthAuthorizePost";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/api/auth/authorize", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ApiAuthAuthorizePost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters 
        /// </summary>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ApiAuthAuthorizePostAsync(string? apiVersion = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            await ApiAuthAuthorizePostWithHttpInfoAsync(apiVersion, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// OAuth 2.0 authorization endpoint - handles authorization code flow with PKCE. Accepts both GET and POST as per OAuth 2.0 spec (RFC 6749 Section 3.1).              Query parameters (validated by OpenIddict before reaching this endpoint):   response_type&#x3D;code (required)   client_id&#x3D;quater-mobile or quater-desktop (required)   redirect_uri&#x3D;... (required, validated against registered URIs)   scope&#x3D;openid email profile offline_access api (optional)   state&#x3D;... (recommended, returned as-is in redirect)   code_challenge&#x3D;... (required when PKCE is enforced)   code_challenge_method&#x3D;S256 (required when PKCE is enforced)              Flow: 1. OpenIddict validates client_id, redirect_uri, code_challenge, code_challenge_method 2. This controller checks if user is authenticated (via cookie) 3. If not authenticated, returns Challenge to redirect to login 4. If authenticated, creates claims principal and issues authorization code 5. Redirects to redirect_uri with code and state parameters 
        /// </summary>
        /// <exception cref="Quater.Desktop.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiVersion"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Quater.Desktop.Api.Client.ApiResponse<Object>> ApiAuthAuthorizePostWithHttpInfoAsync(string? apiVersion = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            Quater.Desktop.Api.Client.RequestOptions localVarRequestOptions = new Quater.Desktop.Api.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Quater.Desktop.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Quater.Desktop.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (apiVersion != null)
            {
                localVarRequestOptions.QueryParameters.Add(Quater.Desktop.Api.Client.ClientUtils.ParameterToMultiMap("", "api-version", apiVersion));
            }

            localVarRequestOptions.Operation = "AuthorizationApi.ApiAuthAuthorizePost";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/api/auth/authorize", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ApiAuthAuthorizePost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
