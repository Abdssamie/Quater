# Implementation Plan: Water Quality Lab Management System

**Branch**: `001-water-quality-platform` | **Date**: 2026-01-25 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-water-quality-platform/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Quater is an open-source, cross-platform water quality lab management system targeting small labs, municipalities, and educational institutions in Morocco. The system comprises three integrated applications (Desktop, Mobile, Backend) with offline-first architecture, bidirectional data synchronization, and built-in compliance reporting for WHO water quality standards. The MVP focuses on core workflows: field sample collection, lab test result entry, and compliance report generation.

**Key Technical Decisions**:
- Authentication: ASP.NET Core Identity (user management) + OpenIddict OAuth2/OpenID Connect (token server)
- PDF Reports: QuestPDF (production-ready, pure C#)
- Mobile Framework: React Native (mature ecosystem, proven track record)
- Mobile Scope: Field sample collection only (no test result entry or reporting)
- Conflict Resolution: Last-Write-Wins with automatic backup of overwritten data
- Location: GPS coordinates + optional text description + optional hierarchy for reporting
- API Documentation: Auto-generated via Swashbuckle.AspNetCore
- TypeScript Generation: NSwag generates TypeScript types and API client from OpenAPI spec
- Audit Archival: 90-day hot/cold split strategy (nightly background job via Quartz.NET)
- Test Methods: Enumeration (Titration, Spectrophotometry, Chromatography, Microscopy, Electrode, Culture, Other)
- Logging: Serilog (Backend/Desktop) + react-native-logs (Mobile)

## Technical Context

**Language/Version**: C# 13 / .NET 10 (Backend + Desktop), JavaScript/TypeScript (Mobile)
**Primary Dependencies**:
- Desktop: Avalonia UI 11.x (cross-platform XAML framework)
- Mobile: React Native 0.73+ (JavaScript/TypeScript framework)
- Backend: ASP.NET Core 10.0, Entity Framework Core 10.0
- Auth: ASP.NET Core Identity (user management) + OpenIddict OAuth2/OpenID Connect (token server)
- Background Jobs: Quartz.NET (audit archival)
- Logging: Serilog (Backend/Desktop), react-native-logs (Mobile)
- PDF: QuestPDF (C# fluent API)
- TypeScript Generation: NSwag (generates TypeScript client from OpenAPI)
- Database: SQLite (client-side), PostgreSQL 15+ (backend)

**Storage**:
- Client: SQLite (offline-first local storage)
- Backend: PostgreSQL (centralized data store)

**Testing**:
- Unit: xUnit + FluentAssertions (backend)
- Integration: xUnit + Testcontainers (for PostgreSQL)
- E2E Desktop: Avalonia UI Testing framework
- E2E Mobile: Jest + React Native Testing Library

**Target Platform**:
- Desktop: Windows 10+, Linux (Ubuntu 20.04+), macOS 11+
- Mobile: Android 8.0+ via React Native (iOS support deferred to Phase 2)
- Backend: Linux server (Docker container)

**Project Type**: Multi-platform (Desktop + Mobile + Backend)

**Performance Goals**:
- Sample creation: <2 minutes (mobile)
- Test result entry: <3 minutes (desktop)
- Report generation: <10 seconds for 100+ samples including PDF export
- Sync: 1,000 samples without data loss or duplication

**Constraints**:
- Offline-first: Desktop and mobile must function without internet for 8-24 hours
- Sync conflicts: 100% correct resolution (no data corruption)
- Backend uptime: 99.5% during pilot phase
- Cross-platform: Single codebase for Windows/Linux/macOS desktop

**Scale/Scope**:
- MVP: 3-5 pilot organizations
- Data: 10,000+ samples without performance degradation
- Users: 10-50 concurrent users per organization
- Parameters: 8 core water quality parameters (pH, turbidity, chlorine, bacteria, temperature, conductivity, dissolved oxygen, hardness)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Constitution Status**: No constitution file found with specific principles. Using general best practices:

✅ **Modularity**: Three separate applications (Desktop, Mobile, Backend) with clear boundaries
✅ **Testability**: All functional requirements have automated test coverage (SC-020)
✅ **Documentation**: Auto-generated OpenAPI/Swagger for API (FR-058), inline comments for complex logic (SC-021)
✅ **Simplicity**: Photo storage removed, OpenIddict for auth, QuestPDF for PDF (reduces custom implementation)
⚠️ **Complexity Warning**: Three separate applications increases coordination complexity
  - **Justification**: Offline-first requirement necessitates separate client apps with local storage
  - **Mitigation**: Shared API contracts (auto-generated OpenAPI), comprehensive sync testing, unified REST API

**Re-evaluation Required After Phase 1**: Verify data model consistency across all three applications

## Project Structure

### Documentation (this feature)

```text
specs/001-water-quality-platform/
├── spec.md              # Feature specification (COMPLETE)
├── plan.md              # This file (IN PROGRESS)
├── research.md          # Phase 0 output (PENDING)
odel.md        # Phase 1 output (PENDING)
├── quickstart.md        # Phase 1 output (PENDING)
├── contracts/           # Phase 1 output (PENDING)
│   ├── api.openapi.yaml # Backend API contract
│   └── sync.schema.json # Sync protocol schema
└── tasks.md             # Phase 2 output (created by /speckit.tasks - NOT by this command)
```

### Source Code (repository root)

```text
# Multi-platform structure: Desktop + Mobile + Backend

backend/
├── src/
│   ├── Quater.Backend.Api/          # ASP.NET Core Web API
│   │   ├── Controllers/             # REST endpoints
│   │   ├── Middleware/              # Auth, logging, error handling
│   │   └── Program.cs
│   ├── Quater.Backend.Core/         # Business logic
│   │   ├── Models/                  # Domain entities
│   │   ├── Services/                # Business services
│   │   └── Interfaces/              # Service contracts
│   ├── Quater.Backend.Data/         # Data access
│   │   ├── Repositories/            # EF Core repositories
│   │   ├── Migrations/              # Database migrations
│   │   └── QuaterDbContext.cs
│   └── Quater.Backend.Sync/         # Sync engine
│       ├── ConflictResolver.cs
│       └── SyncService.cs
└── tests/
    ├── Quater.Backend.Api.Tests/    # API integration tests
    ├── Quater.Backend.Core.Tests/   # Business logic unit tests
    └── Quater.Backend.Sync.Tests/   # Sync engine tests

desktop/
├── src/
│   ├── Quater.Desktop/              # Avalonia desktop app
│   │   ├── Views/                   # XAML views
│   │   ├── ViewModels/              # MVVM view models
│   │   ├── Services/                # Local services
│   │   └── App.axaml
│   ├── Quater.Desktop.Data/         # SQLite data access
│   │   ├── Repositories/
│   │   └── QuaterLocalContext.cs
│   └── Quater.Desktop.Sync/         # Client-side sync
│       └── SyncClient.cs
└── tests/
    ├── Quater.Desktop.Tests/        # UI tests
    └── Quater.Desktop.Data.Tests/   # Data layer tests

mobile/
├── src/
│   ├── components/              # React Native components
│   ├── screens/                 # App screens
│   ├── services/                # API client, sync service
│   ├── storage/                 # SQLite wrapper
│   ├── navigation/              # React Navigation
│   └── utils/                   # Helpers
├── __tests__/                   # Jest tests
├── android/                     # Android native code
├── ios/                         # iOS native code (Phase 2)
└── package.json

shared/
└── api-contracts/               # OpenAPI spec (auto-generated from backend)

docker/
├── docker-compose.yml               # Backend + PostgreSQL
├── erfile.backend               # Backend container
└── init.sql                         # Database initialization
```

**Structure Decision**: Multi-platform structure chosen due to three distinct applications (Desktop, Mobile, Backend) with different deployment targets. Desktop uses Avalonia (.NET/C#), Mobile uses React Native (JavaScript/TypeScript with NSwag-generated API client), Backend uses ASP.NET Core (.NET/C#). Shared API contracts via auto-generated OpenAPI ensure consistency. Each application has its own data access layer (SQLite for clients, PostgreSQL for backend) with a unified REST API and sync protocol. Mobile app scope is limited to field sample collection only (no test result entry or reporting).

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpternative Rejected Because |
|-----------|------------|--------------------------------------|
| Three separate applications | Offline-first requirement + cross-platform support | Single web app rejected: requires internet connectivity; doesn't support offline field work |
| Bidirectional sync engine | Desktop and mobile must work offline and sync later | Real-time sync rejected: unreliable in field conditions with poor connectivity |
| Last-Write-Wins conflict resolution | Simpler than full merge UI while preventing data loss | Manual merge UI rejected: 50% more testing complexity; automatic backup provides safety net |
| NSwag TypeScript generation | Prevents DTO drift between C# backend and TypeScript mobile | Manual TypeScript types rejected: high maintenance burden, prone to errors and version skew |

## Phase 0: Research & Technology Validation

**Status**: COMPLETE

**Unknowns Resolved**:

1. **Desktop/Mobile Framework**
   - Decision: Avalonia for Desktop + React Native for Mobile
   - Rationale: Avalonia mobile is immature; React Native is production-ready with massive ecosystem

2. **Authentication System**
   - Decision: ASP.NET Core Identity (user management) + OpenIddict OAuth2/OpenID Connect (token server)
   - Rationale: Best of both worlds - Identity handles user management, OpenIddict handles token issuance; no vendor lock-in, offline JWT support, native .NET integration, production-ready

3. **PDF Generation**
   - Decision: QuestPDF
   - Rationale: Production-ready (13.7k stars), pure C#, proven performance (2-5s for 100+ PDFs)

4. **Data Access & Sync**
   - Decision: EF Core + SQLite with Last-Write-Wins conflict resolution and automatic backup
   - Rationale: Mature ORM, offline-first compatible, simpler than full merge UI while maintaining data safety

5. **GPS Integration**
   - Decision: react-native-geolocation-service
   - Rationale: Production-ready, offline support, cross-platform

6. **TypeScript Code Generation**
   - Decision: NSwag generates TypeScript client from OpenAPI spec
   - Rationale: Single source of truth, prevents DTO drift, automatic synchronization

7. **API Versioning & Pagination**
   - Decision: `/api/v1/` prefix for all endpoints, pagination with default 100 records per page
   - Rationale: Enables breaking changes without coordinating all client updates; prevents performance issues with large datasets

8. **Audit Log Archival**
   - Decision: 90-day hot/cold split with nightly background job
   - Rationale: Keeps main table small for fast queries; prevents unbounded growth

9. **Logging**
   - Decision: Serilog (Backend/Desktop) + react-native-logs (Mobile)
   - Rationale: Serilog is the .NET industry standard; react-native-logs provides bridge to native console/file systems

10. **Background Jobs**
    - Decision: Quartz.NET
    - Rationale: Lightweight, standard .NET scheduler, supports persistent jobs (needed for reliability)

**Output**: `research.md` with all decisions, rationales, and alternatives considered (COMPLETE)

## Phase 1: Design & Contracts

**Status**: COMPLETE

**Prerequisites**:
- `research.md` complete with all technology decisions finalized ✅

**Deliverables**:

1. **data-model.md**: Complete entity relationship diagram ✅
   - Sample, TestResult, Parameter, User, Lab, SyncLog, AuditLog entities
   - Field definitions with types and constraints
   - Relationships and foreign keys
   - Validation rules from functional requirements
   - State transitions for Sample status (pending/completed/archived)
   - Optimistic locking fields (version, last_modified_timestamp, last_modified_by)

2. **contracts/api.openapi.yaml**: OpenAPI 3.0 specification ✅
   - Note: Will be auto-generated via Swashbuckle.AspNetCore in implementation
   - Manual spec created for reference but will be replaced by auto-generated version
   - Authentication endpoints (OpenIddict integration)
   - Sample CRUD endpoints
   - TestResult CRUD endpoints
   - Sync endpoints (upload/download with conflict detection)
   - Report generation endpoints
   - User management endpoints

3. **contracts/sync.schema.json**: Sync protocol schema ✅
   - Sync request format (device_id, last_sync_timestamp, changes)
   - Sync response format (conflicts, server_changes, new_timestamp)
   - Conflict representation (local_version, remote_version, entity_type)
   - Change log format (entity_type, entity_id, action, data)

4. **Agent context update**: Deferred
   - Will run `.specify/scripts/bash/update-agent-context.sh opencode` after implementation starts
   - Technology stack: .NET 10, Avalonia, React Native, OpenIddict, QuestPDF, PostgreSQL, SQLite
   - Project structure: Multi-platform layout
   - Key architectural decisions: Offline-first, optimistic locking

**Constitution Re-check**: ✅ Data model consistent across applications; sync protocol prevents data corruption via optimistic locking

## Phase 2: Task Breakdown

**Status**: NOT STARTED (created by separate `/speckit.tasks` command)

**Note**: This phase is executed by the `/speckit.tasks` command, NOT by `/speckit.plan`. The task breakdown will be created in `tasks.md` after Phase 1 is complete.

## Next Steps

1. ✅ **Complete Phase 0**: Execute research tasks and create `research.md`
2. ⏳ **Complete Phase 1**: Create data model, API contracts, and quickstart guide
3. ⏳ **Run `/speckit.tasks`**: Generate detailed task breakdown in `tasks.md`
4. ⏳ **Begin Implementation**: Start with backend API and data model

---

**Plan Status**: Phase 0 research required before proceeding to Phase 1 design.
