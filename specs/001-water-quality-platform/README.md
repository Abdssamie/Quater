# Water Quality Lab Management System - Specification

**Feature Branch**: `001-water-quality-platform`  
**Approach**: Monolithic Feature (Single comprehensive specification)  
**Status**: Specifications Complete - Ready for Implementation

---

## üìã Specification Approach

This project uses a **monolithic feature approach** where:

- **One branch** (`001-water-quality-platform`) contains the entire system
- **One spec directory** (`specs/001-water-quality-platform/`) contains all specifications
- **All components** (Backend API, Desktop App, Mobile App, Sync, Reporting) are specified together
- **Implementation** happens on this single branch
- **Merge** to main happens when the complete system is ready

### Why Monolithic?

1. ‚úÖ **Tightly coupled components** - Backend, Desktop, and Mobile share data models, authentication, and sync protocol
2. ‚úÖ **Single source of truth** - No risk of spec drift between components
3. ‚úÖ **Simpler maintenance** - One place to update architecture decisions
4. ‚úÖ **Easier testing** - Full stack can be tested together
5. ‚úÖ **Faster MVP delivery** - No coordination overhead between branches

---

## üìÅ Specification Files

### Core Specifications
- **`spec.md`** (v1.2) - Complete feature specification with user stories (P1-P3)
- **`plan.md`** - Implementation plan, tech stack, project structure
- **`data-model.md`** - Complete data model for all components
- **`research.md`** - Technology research and decisions

### Architecture Documentation
- **`ARCHITECTURE_DECISIONS.md`** - 10 validated architecture decisions with rationale
- **`SPECS_UPDATED.md`** - Summary of maintenance-driven improvements

### Contracts
- **`contracts/sync.schema.json`** - Bidirectional sync protocol specification
- **`contracts/api.openapi.yaml`** - Will be auto-generated by Swashbuckle (not manually maintained)

---

## üèóÔ∏è System Architecture

### Components (All in this spec)

1. **Backend API** (.NET 10 + PostgreSQL)
   - ASP.NET Core Identity + OpenIddict (OAuth2/OIDC)
   - Entity Framework Core 10.0
   - REST API with Swagger/OpenAPI
   - NSwag for TypeScript generation

2. **Desktop App** (Avalonia + SQLite)
   - Cross-platform (Windows, Linux, macOS)
   - Offline-first with local SQLite
   - ReactiveUI MVVM pattern
   - QuestPDF for report generation

3. **Mobile App** (React Native + SQLite)
   - Android only in MVP
   - **Scope**: Field sample collection ONLY (no test entry/reporting)
   - NSwag-generated TypeScript client
   - GPS integration for location capture

4. **Sync Engine** (Last-Write-Wins + Backup)
   - Optimistic locking with version tracking
   - Automatic backup on conflicts
   - User notification with option to view backup
   - Both versions preserved in audit log

---

## üéØ Implementation Strategy

### Phase 0: Setup ‚úÖ COMPLETE
- Project structure created
- Specifications finalized
- Architecture decisions validated

### Phase 1: Backend API (Week 1-4)
- .NET 10 solution setup
- PostgreSQL + Docker configuration
- ASP.NET Core Identity + OpenIddict
- EF Core entities and migrations
- REST API endpoints with Swagger
- Generate OpenAPI spec

### Phase 2: TypeScript Client (Week 2)
- Run NSwag to generate TypeScript client from OpenAPI
- Validate generated types match backend

### Phase 3: Desktop App (Week 5-8)
- Avalonia project setup
- MVVM with ReactiveUI
- SQLite with EF Core
- Sync implementation (Last-Write-Wins + backup)
- QuestPDF report templates

### Phase 4: Mobile App (Week 9-12)
- React Native project setup
- Field sample collection UI
- GPS integration
- SQLite storage
- Manual sync trigger

---

## üîë Key Architecture Decisions

### Decision 1: Authentication
**Choice**: ASP.NET Core Identity + OpenIddict  
**Rationale**: Identity handles user management, OpenIddict handles token issuance

### Decision 2: Mobile Framework
**Choice**: React Native (rejected .NET MAUI)  
**Rationale**: Reliability concerns, large community, extensive package support

### Decision 3: Mobile Scope
**Choice**: Field sample collection ONLY  
**Rationale**: Mobile app is for field technicians, not full lab features

### Decision 4: Conflict Resolution
**Choice**: Last-Write-Wins with automatic backup  
**Rationale**: 50% reduction in testing complexity, user-friendly

### Decision 5: TypeScript Generation
**Choice**: NSwag auto-generates from OpenAPI  
**Rationale**: Eliminates contract drift risk

### Decision 6: API Versioning
**Choice**: `/api/v1/` prefix for all endpoints  
**Rationale**: Enables breaking changes in future versions

### Decision 7: Test Methods
**Choice**: Enumeration (7 standard methods + Other)  
**Rationale**: Consistent data quality, better reporting

### Decision 8: Audit Archival
**Choice**: 90-day hot/cold split with nightly job  
**Rationale**: Maintains query performance as data grows

### Decision 9: Location Hierarchy
**Choice**: Optional field for better reporting  
**Rationale**: Supports complex organizational structures

### Decision 10: Threshold Versioning
**Choice**: Explicitly rejected (too complex for MVP)  
**Rationale**: Can be added in Phase 2 if needed

See `ARCHITECTURE_DECISIONS.md` for full details.

---

## üìä Maintenance Impact

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| **Testing Complexity** | User-prompted conflicts | Last-Write-Wins + backup | 50% reduction |
| **Contract Drift Risk** | Manual TypeScript | NSwag auto-generation | Eliminated |
| **Mobile Development Time** | Full feature parity | Field collection only | 40% faster |
| **API Evolution** | No versioning | `/api/v1/` prefix | Breaking changes possible |
| **Query Performance** | Unbounded audit logs | 90-day archival | Maintained |
| **Data Quality** | Free-text test methods | Enumeration | Consistent |

---

## üöÄ Next Steps

### Option A: Generate Task Breakdown (Recommended)
Run `/speckit.tasks` to generate `tasks.md` with:
- Structured task breakdown by user story
- Dependency graph
- Parallel execution opportunities
- Independent test criteria per story

### Option B: Start Implementation Directly
Begin with backend API:
1. Set up .NET 10 solution structure
2. Configure PostgreSQL + Docker
3. Implement ASP.NET Core Identity + OpenIddict
4. Build EF Core data model
5. Create REST API endpoints with Swagger

---

## üìù Document History

- **v1.2** (2025-01-26): Maintenance-driven improvements, 10 architecture decisions validated
- **v1.1** (2025-01-25): Initial comprehensive specification
- **v1.0** (2025-01-25): Project initialization

---

## üîó Related Documentation

- [Architecture Decisions](./ARCHITECTURE_DECISIONS.md) - Detailed decision rationale
- [Specs Update Summary](./SPECS_UPDATED.md) - Complete change log
- [Feature Specification](./spec.md) - User stories and requirements
- [Implementation Plan](./plan.md) - Tech stack and structure
- [Data Model](./data-model.md) - Complete entity definitions
- [Technology Research](./research.md) - Technology choices and alternatives

---

**Status**: üéâ **READY FOR IMPLEMENTATION**

All specifications are complete, validated, and committed. The architecture is optimized for long-term maintainability with proven, production-ready technologies.
